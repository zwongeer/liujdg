## 如何调用 `刘稼级`

###  运行

```
$ liujdg.run <json配置文件路径> [错误日志路径]
```

* 对于调用者，需要向`liujdg`传入一个`json`配置文件路径（必选），和一个错误日志保存的路径（可选），如果没有传入错误日志路径或者该路径无法写入，则`liujdg`会从`stderr`发出一个警告。

* 以下是一个`json`样例：
* 注意：`json`中的大小写是敏感的

```json
 {
  "players": [
    {
      "name": "attack204-0",
      "id": "attack204-0-no-root",
      "build": "g++ -std=c++17 p1.cpp -o p1",
      "run": "./p1",
      "folder": "data",
      "basedir": "p1"
    },
    {
      "name": "attack204-1",
      "id": "attack204-1-no-root",
      "build": "g++ -std=c++17 p2.cpp -o p2",
      "run": "./p2",
      "folder": "data",
      "basedir": "p2"
    }
  ],
  "judger": {
    "name": "attack204-self",
    "id": "at20",
    "build": "",
    "run": "./judger",
    "folder": "data/",
    "basedir": "./judger"
  },
  "config": {
    "logdir": "./log",
    "basedir": ".",
    "timeLimit": 5
  }
}
```

* 其中`config`包含了` 刘稼级`主程序的运行配置。在` 刘稼级`运行时，` 刘稼级`会首先将当前工作路径切换到`basedir`所在路径，之后会尝试打开`logdir`，用来保存战局结果和每个子程序的`stdout`输出。`timeLimit`代表着每一步的限时，如果在时限之内主程序无法接受到子进程的消息，将会直接结束程序，步骤如下：从`stdin`向所有子进程发送一个字符串`#kill`，继续等待一个`timeLimit`时间后，主程序会强行终止所有子进程，并将错误信息写入日志文件（调用时第三个命令行参数所在路径），之后退出。
* 其中`judger`包含了裁判所对应的运行参数，当调用` 刘稼级`时，` 刘稼级`会先将子进程的当前工作目录切换到`judger`的`basedir`，再运行`judger`中的`run`命令。
* 其中`players`中包含了所有玩家的数组（可以有多个），当调用` 刘稼级`时，` 刘稼级`会依次将子进程的当前工作目录切换到`players`的`basedir`，再运行`players`中的`run`命令。
* 如果程序可以正常退出（没有在时限内收到消息、裁判发出了错误的指令），退出步骤于上述步骤相同。
* 如果程序读取配置文件失败，或者是没有写入文件的权限，则会在初始化时直接退出，而不会等待`timeLimit`时间，并且向错误日志中写入错误原因。（`timeLimit`为可选的）
* 因为`Linux`的原因，如果可执行文件路径在当前目录，需要在前面加上`./`，如`./main`（也可以把`.`加入环境变量）



## 首先要知道的

1. ` 刘稼级`会给每一个子进程分配一个id(从0~n)，分配给裁判的id永远是0，玩家的id会随机分配（不按`json`中的顺序）。

1. 注意：
	- ` 刘稼级`每次会从子程序的`stdout`中读取一行，由于程序设计的限制，每行的内容不应该超过4096个字符（包括‘\0’），否则你的程序会被直接终止。
	- 建议每次输出后对输出流进行刷新，建议使用`std::endl`（换行并刷新）。
	
### 对局结果样例

`result.json`文件：

```json
{
  "players": [
    {
      "name": "attack204-0",
      "id": "attack204-0-no-root",
      "scores": 0,
      "isWinner": false
    },
    {
      "name": "attack204-1",
      "id": "attack204-1-no-root",
      "scores": 1,
      "isWinner": true
    }
  ],
  "comments": "Good!"
}
```

`0~n.txt`文件：

```
分别对应了每个子进程的stdout输出
需要注意的是，该日志文件的编号是按照json中的玩家顺序，但是传递给裁判的玩家id是随机顺序。也就是说该日志文件的编号与游戏中玩家的id可能不同，但是裁判的序号都是0
```



### 可能以后会解决的问题（现在懒得改了～～～）：

1. 对于每一个输出，一定需要进行换行，否则会被认为是一次输出，会造成格式错误。
2. 不应该输出空行，因为空行也会被视为一个内容，会导致裁判收不到输入内容。



## 出题人 & 裁判

对于裁判，在初始化时会从`stdin`接受到2行参数：

* 玩家数量

* 可以用来储存数据的文件夹路径

初始化时，` 刘稼级`会等待裁判进行操作：

裁判可以执行若干个命令(大小写敏感，命令应该在每行的开头，而且命令前不应该有任何字符、包括空格)：

1. send
   - 由两行构成
   
   - 语法：
   
   - 第一行`send <玩家id列表（以空格分隔）>`
   
   - 第二行`<要发送给相应玩家的消息>`
   
   - 如果玩家id列表中只有一个数字0，则会向所有玩家发送消息
   
   - 其它情况下，会向对应的玩家发送消息，如果裁判尝试向一个不存在的玩家发送消息，`刘稼吉`会提示一个std::out_of_range，并且终止程序，同时记录错误
   
   - 例子：
   
   - ```
     send 0
     hello //向所有玩家发送hello，实际应用之中不应该有注释，此处只是说明
     ```
   
   - ```
     send 1 2 3
     giao giao //向id为1,2,3的玩家发送'giao giao'
     ```
   
2. continue

   - 由一行构成

   - 语法：`continue <单个玩家id>`

   - 发送该命令后`刘稼级`会尝试从id所对应玩家的`stdout`中读取消息，假设读取的消息为message，之后会将`玩家id message`发送给裁判（包括换行符）。

   - 例子：

   - ```
     continue 1
     /*
     之后假设id为1的玩家从stdout输出了'giao oaig'
     裁判会收到'1 giao oaig'
     如果裁判尝试从一个不存在的玩家接收消息，`刘稼吉`会提示一个std::out_of_range，并且终止程序，同时记录错误
     */
     ```

3. win

   - 由2～3行构成

   - 语法：

   - ```
     win [玩家id列表（以空格分隔，可以为空）]
     <玩家分数列表（以空格分隔）>
     [评论（可选）]
     ```

   - 例子：

   - ```
     // 假设有2个玩家，id分别为 1 2
     win 1
     1 0
     Have a nice day!
     /*
     第一行：告诉主程序胜利的玩家
     第二行：给每个玩家打分（必选）
     第三行：留下评论（可选）
     */
     ```

4. draw

   - 由2～3行构成

   - 语法：

   - ```
     draw
     <玩家分数列表（以空格分隔）>
     [评论（可选）]
     /*
     和win命令类似，只不过没有胜利玩家
     与没有胜利玩家的win命令等价
     */
     ```





## 玩家

对于玩家，在初始化时会从`stdin`接受到3行参数：

* 玩家数量n
* 自己被分配到的id(可能为1~n)
* 可以用来储存数据的文件夹路径

初始化时，` 刘稼级`会等待裁判进行操作：

```
参见出题人给出的输入输出格式
```

